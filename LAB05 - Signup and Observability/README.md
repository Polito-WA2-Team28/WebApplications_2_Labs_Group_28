# LAB05 - Team28

## The web application

### Structure of the application

The web application developed in this laboratory has the following components:
- the **PostgreSQL database** containerized and deployed with a docker-compose configuration file. The PostgreSQL instance is listening on port 5432.
- the **SpringBoot backend** service running with Gradle and exposing the required APIs on port 8081;
- the **Keycloak IAM** service, running on port 8080, manages user registrations and authentications.
- the **Loki** service, used to store and index logs efficiently.
- the **Grafana** service, running at port 3000, used to visualize the logs collected by Loki. The dashboard used is Spring Boot Observability.
- the **Prometheus** service, used to scrape and store metrics.

## The Keycloak IAM

### Configuration
In our Keycloak instance we have created an additional realm called `TicketingServiceRealm` that will be responsible for the  management of the users and clients of our ticketing service. In this realm, we have also set up:
- a client that will manage the interactions with the ticketing service, called: `ticketing-service-client`.
- a user `admin` that the keycloak client will exploit to communicate with our keycloak instance.

### Authentication endpoints
We have defined and implemented the following endpoints to register and login into the application:
- `POST /api/auth/register`  \
  This endpoint, upon receiving user information, will automatically save the user onto keycloak and once the process is completed, the same user will also be saved on our PostgreSQL instance.
  The logical connection between the Keycloak user and the PostgreSQL user is obtained through the `UUID` generated by Keycloak and also saved on our database.
- `POST /api/auth/login` \
  This endpoint, upon receiving user's credentials, will interact with Keycloak to check the correctness of the user's credentials. If the authentication process is successful, the user will receive a **JWT** `accessToken` that will be used to authenticate the upcoming requests to the other APIs.

## Deployment
The application has been deployed as a set of microservices on docker-compose. Every custom image we are using is retrieved from our personal repository on Docker Hub.

### Run the application

To run the application:

1. Start the TicketService instance (in *detached* mode) with:
   
    ```
    cd Docker
    docker-compose up -d
    ```

3. Access the web application with any browser by reaching `localhost:8081`.




- Create customer functionality both on keycloak and postgres  => customer is created on keycloak and uuid generated by keycloak is saved in postgres   /api/auth/register
- Create expert (only for manager) functionality both on keycloak and postgres  => expert is created on keycloak and uuid generated by keycloak is saved in postgres   /api/auth/createExpert
- Login user /api/auth/login
- Observability stack
  - grafana :3000 => dashboard "Spring Boot Observability V2"
  - tempo, loki, prometheus
- Inside controllers we only log generic errors (authentication, authorization, ...)