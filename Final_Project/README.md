# LAB05 - Team28

## The web application

### Structure of the application

The web application developed in this laboratory has the following components:
- the **PostgreSQL database** containerized and deployed with a docker-compose configuration file. The PostgreSQL instance is listening on port 5432.
- the **SpringBoot backend** service running with Gradle and exposing the required APIs on port 8081;
- the **Keycloak IAM** service, running on port 8080, manages user registrations and authentications.
- the **Loki** service, used to store and index logs efficiently.
- the **Grafana** service, running at port 3000, used to visualize the logs collected by Loki. The dashboard used is Spring Boot Observability.
- the **Prometheus** service, used to scrape and store metrics.

## The Keycloak IAM

### Configuration
In our Keycloak instance we have created an additional realm called `TicketingServiceRealm` that will be responsible for the  management of the users and clients of our ticketing service. In this realm, we have also set up:
- a client that will manage the interactions with the ticketing service, called: `ticketing-service-client`.
- a user `admin` that the keycloak client will exploit to communicate with our keycloak instance.

### Authentication endpoints
We have defined and implemented the following endpoints to register and login into the application:
- `POST /api/auth/register`  \
  This endpoint, upon receiving user information, will automatically save the user onto keycloak and once the process is completed, the same user will also be saved on our PostgreSQL instance.
  The logical connection between the Keycloak user and the PostgreSQL user is obtained through the `UUID` generated by Keycloak and also saved on our database.
- `POST /api/auth/login` \
  This endpoint, upon receiving user's credentials, will interact with Keycloak to check the correctness of the user's credentials. If the authentication process is successful, the user will receive a **JWT** `accessToken` that will be used to authenticate the upcoming requests to the other APIs.

### Expert endpoints
Definition and implementation of required expert endpoint was added to allow registered managers to create new expert instances:
- `POST /api/auth/createExpert` \
  This endpoint, upon receiving expert information, will automatically save the expert onto keycloak and once the process is completed, the same expert will also be saved on our PostgreSQL instance.
  The logical connection between the Keycloak expert and the PostgreSQL expert is obtained through the `UUID` generated by Keycloak and also saved on our database.

### Monitoring and obserbavility
The application utilizes an observability stack consisting of multiple tools that provide valuable insights into its performance and behavior. The stack includes the following components:

#### Grafana:
 Serves as a centralized dashboard for monitoring and analyzing various metrics and data from the application. By accessing Grafana at http://localhost:3000, you can explore the "Spring Boot Observability V2" dashboard specifically designed to display relevant metrics.

#### Tempo:
 It allows you to capture and analyze the flow of requests across the application's components and microservices. Tempo provides valuable insights into latency, dependencies, and performance bottlenecks.

#### Loki: 
It collects logs from different sources, including the application, and provides a powerful query language for searching and analyzing log data. Loki simplifies log management, making it easier to identify and troubleshoot issues by examining relevant logs.

Within the application's controllers, specific logging practices are followed. Only generic errors such as authentication and authorization issues are logged. This approach ensures that crucial security-related events are captured for auditing purposes and helps in identifying and resolving potential security vulnerabilities.

#### Prometheus:
 It collects and stores metrics from various sources, including the application, and provides a flexible querying language for analyzing and visualizing metrics data. Prometheus enables proactive monitoring, alerting, and capacity planning by tracking key performance indicators.

To set up the monitoring and observability stack, the following guide was followed:[Spring Boot 3 Observability: Monitor Application on the Method Level](https://medium.com/spring-boot/spring-boot-3-observability-monitor-application-on-the-method-level-8057abec5926). The provided Docker Compose configuration enables the deployment of the monitoring stack, while the inclusion of Micrometer dependencies in the application allows for the seamless transmission of data to the observability stack.

## Deployment
The application has been deployed as a set of microservices on docker-compose. Every custom image we are using is retrieved from our personal repository on Docker Hub.

### Run the application

To run the application:

1. Start the TicketService instance (in *detached* mode) with:
   
    ```
    cd Docker
    docker-compose up -d
    ```

2. Access the web application with any browser by reaching `localhost:8081`.